//=====================
// Basic SWHT function
//=====================


#include "swht_kernel.h"
#include "Hasher.h"
#include "cs_factory.h"

#include "build_info.h"
#ifdef PROFILING_BUILD
    #include "profiling.h"
    DURATION_READY
#endif

#include "fastwht/hadamardKernel.h"

#include <cmath>
#include <vector>


#define TOLERANCE 0.005


/** SWHT
 * Non-robust SWHT core function.
 * 
 * @param signal: Observed signal
 * @param current_estimate: Output as a frequency-amplitude map
 * @param n: Set dimension
 * @param K: Sparsity
 * @param C: Bucket constant
 * @param ratio: Buckets reduction ratio
 * @param n_bins: (random binning - optional) number of bins for binary search
 * @param iterations: (random binning - optional) number of iterations for binary search
 * @param bin_ratio: (random binning - optional) bins reduction ratio for binary search
 * @param degree: (Reed-Solomon - optional) degree of the frequencies of the signal
 */
template <int cs_algorithm, typename ... Args> 
int swht_basic(PyObject *signal, frequency_map &current_estimate, unsigned long n, unsigned long K, double C, double ratio, Args ... cs_args) {
    
    // Base parameters
    #ifdef PROFILING_BUILD
        SECTION_START(init)
    #endif
    unsigned long B = K * C;                                                // number of buckets we are hashing into (to be rounded up)
    unsigned long b = ceil(log2(B));                                        // index bit-size for the buckets
    unsigned long T = (unsigned long)(log(B) / log(ratio)) - 1ul;           // number of iterations to perform
    finite_field_cs *cs_provider = get_finite_field_cs<cs_algorithm>(n, cs_args...);    // finite field cs provider
    #ifdef PROFILING_BUILD
        SECTION_END(init)
    #endif

    const bit *zero_shift = new bit[n]();

    for (unsigned long i = 0ul; i < T; i++) {
        
        // Create hashing processor
        #ifdef PROFILING_BUILD
            SECTION_START(hasher)
        #endif
        Hasher hash(n, b, signal);
        cs_provider->update();
        unsigned long N = cs_provider->number_of_measurements;
        #ifdef PROFILING_BUILD
            SECTION_END(hasher)
        #endif


        // Current frequency estimate hashing
        //===================================
        // Map all the current frequency-amplitude estimates to the bucket
        // corresponding to their hashed frequency for later subtraction
        // from the hased and transformed buckets.

        #ifdef PROFILING_BUILD
            SECTION_START(current_hash)
        #endif
        std::vector<std::pair<vbits, double>> *hashed_estimate = new std::vector<std::pair<vbits, double>>[hash.B]();
        for (auto it = current_estimate.begin(); it != current_estimate.end(); it++) {
            bits hashed_frequency = hash.frequency_hash(it->first);
            hashed_estimate[hashed_frequency].push_back(*it);
        }
        #ifdef PROFILING_BUILD
            SECTION_END(current_hash)
        #endif


        // Source signal sampling
        //=======================
        // Sample the source signal (time-domain) then transform it (frequency-domain)
        // without shifting (reference signal) and with shifts generated by the cs
        // provider for later comparison.

        // #ifdef PROFILING_BUILD
        //     SECTION_START(sampling)
        // #endif

        // Compute reference signal transformed hash (shift = 0)
        double *reference_signal = new double[hash.B];
        hash.time_hash(zero_shift, reference_signal);
        #ifdef PROFILING_BUILD
            SECTION_START(transform)
        #endif
        fwhtKernelOrdinary(hash.B, reference_signal);
        for (unsigned long j = 0ul; j < hash.B; j++) reference_signal[j] /= hash.B;
        #ifdef PROFILING_BUILD
            SECTION_END(transform)
        #endif

        // Compute all shifted signal transformed hashes according to detection algorithm
        double *hashed_WHT = new double[N * hash.B];
        for (size_t k = 0ul; k < N; k++) {
            double *hashed_signal = hashed_WHT + k * hash.B;
            const bit *shift = cs_provider->measurement_matrix_row(k);
            hash.time_hash(shift, hashed_signal);
            #ifdef PROFILING_BUILD
                SECTION_START(transform)
            #endif
            fwhtKernelOrdinary(hash.B, hashed_signal);
            for (unsigned long j = 0ul; j < hash.B; j++) hashed_signal[j] /= hash.B;
            #ifdef PROFILING_BUILD
                SECTION_END(transform)
            #endif
        }

        // #ifdef PROFILING_BUILD
        //     SECTION_END(sampling)
        // #endif


        // Detect and extract frequencies from buckets
        //============================================
        // For each bucket of the reference signal, find a target (non-hashed) frequency
        // to map it to, while ensuring maximum sparsity through subtraction of previously
        // extracted frequencies.

        #ifdef PROFILING_BUILD
            SECTION_START(detection)
        #endif

        // Iterate through each bucket (frequency hash)
        frequency_map detected_frequency;
        for (bits bucket = 0ul; bucket < hash.B; bucket++) {

            // Subtract current estimate from hashed frequencies to increase sparsity
            for (const std::pair<vbits, double> &X: hashed_estimate[bucket])
                reference_signal[bucket] -= X.second;
            if (std::abs(reference_signal[bucket] - 0.0) < TOLERANCE)
                continue; // ignore near-zero amplitudes!
            if (!hashed_estimate[bucket].empty()) {
                for (unsigned long j = 0ul; j < N; j++) {
                    for (const std::pair<vbits, double> &X: hashed_estimate[bucket]) {
                        if (cs_provider->inner_product(X.first, j)) {
                            hashed_WHT[j * hash.B + bucket] += X.second;
                        } else {
                            hashed_WHT[j * hash.B + bucket] -= X.second;
                        }
                    }
                }
            }

            // Compute bit-wise measurement based on sign shifting from the inner product
            vbits measurement(N, 0u);
            for (unsigned long j = 0ul; j < N; j++) {
                if (hashed_WHT[j * hash.B + bucket] * reference_signal[bucket] < 0.0) {
                    measurement[j] = 1u;
                }// else {
                //     measurement[j] = 0u;
                // }
            }

            // Recover the actual frequency from the measurement using the cs recovery algorithm
            cs_provider->recover_frequency(measurement);
            detected_frequency[measurement] = reference_signal[bucket];
        }

        // Detection arrays cleanup
        delete[] hashed_estimate;
        delete[] reference_signal;
        delete[] hashed_WHT;

        #ifdef PROFILING_BUILD
            SECTION_END(detection)
        #endif


        // Iterative updates
        //==================
        // Add detected frequencies to the current estimate (or sum them if they already exist)
        // and purge estimated frequencies that have become too close to zero.

        #ifdef PROFILING_BUILD
            SECTION_START(updates)
        #endif

        for (auto &&frequency: detected_frequency) {
            auto match = current_estimate.find(frequency.first);
            if (match != current_estimate.end()) {
                match->second += frequency.second;
                if (std::abs(match->second - 0.0) < TOLERANCE)
                    current_estimate.erase(match);
            } else {
                current_estimate[frequency.first] = frequency.second;
            }
        }

        // Buckets sizes reduction
        B = std::ceil(B / ratio);
        b = ceil(log2(B));

        #ifdef PROFILING_BUILD
            SECTION_END(updates)
        #endif
    }

    // Final cleanup
    delete[] zero_shift;
    
    // Return estimate
    delete cs_provider;
    return 0;
}

// Per-algorithm instantiations
template int swht_basic<NAIVE_CS>(PyObject *signal, frequency_map &out, unsigned long n, unsigned long K, double C, double ratio);
template int swht_basic<RANDOM_BINNING_CS, unsigned long, unsigned long, double>(
    PyObject *signal, frequency_map &out, unsigned long n, unsigned long K, double C, double ratio, unsigned long cs_bins,
    unsigned long cs_iterations, double cs_ratio);
template int swht_basic<REED_SOLOMON_CS, unsigned long>(PyObject *signal, frequency_map &out, unsigned long n, unsigned long K,
    double C, double ratio, unsigned long degree);
